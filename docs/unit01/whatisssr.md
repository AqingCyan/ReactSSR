# 了解服务端渲染

前面提到，现在常用的前后端分离开发模式下，大多数网页是基于客户端渲染的。那么就不可避免的产生了一些问题：SEO差，首屏加载时间长等。因此，SSR 模式就很合时宜的出现了。

## 老瓶装新酒

最近几年浏览器端框架很繁荣，以至于很多新入行的开发者只知道浏览器端渲染框架，都不知道存在服务器端渲染这回事，其实，网站应用最初全都是服务器端渲染，由服务器端用 PHP、Java 或者 Python 等其他语言产生 HTML 来给浏览器端解析。

> 因此，现在提到的 SSR 实际上是一个老瓶装新酒的技术，后面再提新的地方。

那我们现在就可以很快的做一个示例，来对比一下之前的 CSR：

创建一个文件夹，并且执行 `npm init -y`，然后进行以下操作：

```shell script
npm install express
```

然后打开项目，创建一个 `app.js` 文件：

```js
const express = require('express')

const app = express()

app.get('/', (req, res) => res.send('Hello World'))

app.listen(10086, () => console.log('Example app listening on port 10086!'))
```

此时，`node app.js` 运行该文件，访问 `localhost:10086` 可以看到网页呈现了一行话，内容是 `Hello World`。这行内容，就是在我们访问根路径的时候，
`res.send` 给发送来的内容。但如果我们不仅仅想让它发送字符串：

```js
app.get('/', (req, res) => res.send(`
  <html lang="zh-CN">
    <head>
      <title>react ssr</title>
    </head>
    <body>
      <h1>Hello World</h1>
    </body>
  </html>
`))
```

此时，再访问页面，得到的就是一个一级标题，内容仍然是 `Helle World`。

那我们作为对比，一样去查看网页源代码，可以看到页面的内容就是源代码呈现的内容，并且它和我们通过 `res.send` 发送的内容是一模一样的。也就是说，
我们请求到了什么内容，就渲染出什么内容，而这个内容是由服务器发送过来的内容决定的，因此，这个页面，我们称为是服务端进行渲染的。

> 服务端渲染，SSR，全称为：server side render

## 服务端渲染的优势

**可以缩短“第一有意义渲染时间”（First-Meaningful-Paint-Time）：**

如果完全依赖于浏览器端渲染，那么服务器端返回的 HTML 就是一个空荡荡的框架和对 JavaScript 的应用，然后浏览器下载 JavaScript，再根据 JavaScript 中的 AJAX 调用获取服务器端数据，再渲染出 DOM 来填充网页内容，总共需要三个 HTTP 或 HTTPS 请求。

如果使用服务器端渲染，第一个 HTTP/HTTPS 请求返回的 HTML 里就包含可以渲染的内容了，这样用户第一时间就会感觉到“有东西画出来了”，这样的感知性能更好。

**更好的搜索引擎优化（Search-Engine-Optimization，SEO）：**

大部分网站都希望自己能够出现在搜索引擎的搜索页前列，这个前提就是网页内容要能够被搜索引擎的爬虫正确抓取到。虽然 Google 这样的搜索引擎已经可以检索浏览器端渲染的网页，但毕竟不是全部搜索引擎都能做到，如果搜索引擎的爬虫只能拿到服务器端渲染的内容，完全浏览器端渲染就行不通了。

即使对于 Google，网页性能也是搜索排名的重要指标，如果通过服务器端渲染提高网页性能，网页的排名更可能靠前。

## 服务端渲染的缺点

虽然与 CSR 相比，弥补了以上提到的两点 CSR 无法做到的缺点，但往往就是因为此，它的缺点也十分的明显：

首先，因为渲染的部分都放在了服务端，因此，对服务端无疑增加了一些压力，当访问量过大时，就会造成很大性能消耗。

页面都放在了服务端去生成，那么页面的效果与可操作性就会大打折扣。除开上面的问题，我们回避了前端页面还有 JS 的一席之地。
我们知道，在服务端中，不存在页面这个概念，更没有 DOM 可以去操作。说白了，本质上是服务端进行了字符串的拼接，拼凑出来了一个页面。
那我们需要有一个精美的交互性强的页面，就显得无可奈何了。

最后，CSR 做到了前后端分离，极大的提升了效率，服务端渲染下的开发，必然会造成效率降低。

## 装的什么新酒

既然如此，CSR 与 传统的 SSR 都无法达到一个完美的程度，那必然会有一个较好的方案去解决以上问题。

那么基于 MVVM 模式下的框架，在进行服务端渲染开发时，引入了一个同构的概念。这也是现在 SSR 的一个重要概念。
虽然现在的服务端渲染的本质还是服务端去生成页面发送到前端。但与过去不同，在同构下，代码需要在服务端与客户端都运行，来保证页面完整高级与高性能。

与此同时，我们也改进了服务的结构，由原先的：Client 到 Server。变成了：Client 到 Render-Server 再到 Server。如果再访问量较大的情况下，
我们只需要增加 Render-Server（片面这么理解，性能优化是门高级学问），就可以保证性能稳定。

如此新酒，就要求前端开发掌握较为全面的全栈知识，下面，我们就尝试着去基于 React，从零实现一个 SSR 模型。

!> SSR 远不止上面提到这些问题，基于 React 的 SSR 更是。
